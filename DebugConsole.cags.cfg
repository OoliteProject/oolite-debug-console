[Settings]
SaveConfigOnExit = yes
SaveHistoryOnExit = yes
Port = 49999
EndPort = 50003
ServerAddress = 127.0.0.1
HideDefaultComments = no           // toggles the appearance of default comments (like this one) in this file
EnableShowConsole = no             // master toggle for 3 "Show Console for ..." in Debug menu
                                   //   will be automatically set if any of the 3 are turned on
OldClearBehaviour = no             // command box 'Clear' button clears the output (upper) window, not the command line
MacroExpansion = yes               // show "macro-expansion" messages when executing macros
TruncateCmdEcho = yes              // shorten command echos to a single line
ResetCmdSizeOnRun = yes            // resize cmdLine window after a command is run
MsWheelHistory = no                // toggle for using the mouse wheel to scroll the command history
PlistOverrides = no                // if yes, colors & fonts are replaced with those from Oolite
FormatAliasFns = yes               // toggle formatting an alias that is a function/IIFE
                                   //   also used to detect .cfg from previous version
                                   //   (if you want to restore all default comments, just delete this option)
MaxHistoryCmds = 200               // maximum # of commands in the command history
MaxBufferSize = 200000             // upper limit on the size (bytes) of the command history
ColorMenus = yes                   // toggle for applying colors to menus
ColorPopups = yes                  // toggle for applying colors to popup menus
ColorButtons = yes                 // toggle for applying colors to buttons
/*
 * internal, alter at your own risk
 */
Geometry = 1791x965+765+1
SashOffset = 800
BaseTimingMS = 5                   // base rate (milliseconds) for network msgs
FindToolTipDelayMS = 1000          // delay (milliseconds) before showing tool tips in Finder window
                                   //  - set to 0 to disable them
SearchToolTipDelayMS = 1000        // delay (milliseconds) before showing tool tips in text window Search box
                                   //  - set to 0 to disable them
/*
 * list of remaining tool tips.  Can also be set to all or none
 */
ToolTips = ["searchTarget", "searchTargetClear", "searchCountBtn", "searchMarkall", "searchBackwardsBtn", "searchWordsOnlyBtn", "searchWrapBtn", "searchRegexBtn", "grepPath_Entry", "grepOxzFilesBtn", "allBox", "checkedBox", "clearChecked", "deleteChecked", "grepExcl_Entry", "grepIncl_Entry", "grepText_Entry", "grepMatchAllBtn", "grepQuitOnFirstBtn", "grepContextNum", "grepTreatToken", "grepTreatWord", "grepTreatSubstring", "grepTreatRegex", "grepTreatFile", "aliasPollCheck", "aliasAsButton", "clk_aliasMenuButton", "fCon_aliasMenuButton", "fFar_aliasMenuButton", "fHunt_aliasMenuButton", "fMil_aliasMenuButton", "fMine_aliasMenuButton", "fNavHostile_aliasMenuButton", "fOff_aliasMenuButton", "fPirate_aliasMenuButton", "fPol_aliasMenuButton", "fTrade_aliasMenuButton"]

[Font]
/*
 * these 2 exist in console.settings (as font-face, font-size),
 * so changes of these are also stored there, when PlistOverrides is set
 */
Family = Tahoma
Size = 16                          /* Tk: "The font height as an integer in points.
                                           To get a font n pixels high, use -n" */
/*
 * these 3 are only saved locally, as they are not a part of Oolite
 */
Weight = normal                    // "bold" for boldface, "normal" for regular weight
Slant = roman                      // "italic" for italic, "roman" for un-slanted
disabled = normal                  // "overstrike" or "normal" (adds strike-through for visibility)

[Colors]
/*
 * colors used in debug console, when PlistOverrides is not set
 * they can be specified by any of the 502 (!) Tk names, like:
 *   black, red, green, blue, cyan, yellow, magenta, white, gray100, deep pink,
 *   deep sky blue, turquoise4, LawnGreen, goldenrod1, MediumOrchid1,
 *   cornflower blue, blanched almond, peach puff, PaleVioletRed, saddle brown, ...
 * or Oolite color names:
 *   blackColor, darkGrayColor, grayColor, lightGrayColor,
 *   whiteColor, redColor, greenColor, blueColor, cyanColor,
 *   yellowColor, magentaColor, orangeColor, purpleColor, brownColor
 * or custom colors as a string in the format "#rrggbb" (or "#rgb"),
 *   where rr, gg, bb are 2 digit hexadecimals, so the first list starts with:
 *   #000000, #ff0000, #00ff00, #0000ff, #00ffff, #ffff00, #ff00ff, #ffffff
 */
General-foreground = yellow
General-background = black
Command-foreground = #80ff80
Command-background = black
Select-foreground = black
Select-background = sienna1

[History]
AliasWindow = 1484x749+1063+547    // geometry of alias editor.
AliasSashOffset = 176
// AliasSashOffset = (189, 1)
FinderWindow = 1552x819+1008+88    // geometry of file search window
FindSashOffset = 236
SearchTerms = ["docked_huds", "wildefire", "curr_S", "shipTargetAcquired,", "grow_new_list", "update_one_Sighting"]// common listbox history (max. 20) of search windows
SearchLog = [577, 290]             // location of output search window
SearchAlias = [1316, 95]
/*
 * listbox history (max. 20) of file Search paths
 */
FindPaths = ["D:\\Oolite\\oolite.app\\GNUstep\\Library\\ApplicationSupport\\Oolite\\ManagedAddOns", "D:\\Oolite\\AddOns", "D:\\Oolite\\oolite.app\\GNUstep\\Library\\ApplicationSupport\\Oolite\\ManagedAddOns\\HUDs", "D:\\Oolite", "D:\\Oolite\\AddOns\\Norby.cag.Telescope.oxp", "D:\\Oolite.org-oxzs", "D:\\Oolite.org-oxzs\\Her Imperial Majesty's Space Navy", "D:\\Oolite\\AddOns\\himsn-master.oxp\\Scripts", "D:\\play Oolite", "D:\\Oolite\\oolite.app\\Resources", "D:\\Oolite\\oolite.app\\GNUstep\\Library\\ApplicationSupport\\Oolite", "D:\\Oolite\\AddOns\\Basic-debug.oxp", "D:\\Oolite\\AddOns\\Resources", "D:\\Oolite\\oolite.app\\Logs", "D:\\Oolite\\oolite.app\\oolite-saves"]
/*
 * listbox history (max. 20) of file search File types & its 'checked' status
 */
FindTypes = [["*.js", [" "]], ["*.plist", [" "]], ["*/*.oxp", [" "]], ["*.oxz", [" "]], ["shipdata.plist", [" "]], ["*.js, *.plist", [" "]], ["manifest.plist", [" "]], ["*.txt", [" "]], ["*.js, *.txt", [" "]], ["*.plist, *.txt*.js; *.plist; *.txt", [" "]]]
/*
 * listbox history (max. 20) of file Search excluded types & its 'checked' status
 */
FindExcls = [["*publish*/", [" "]], ["_removed -performance/", ["X"]], [".cag/", ["X"]], ["*-not loaded/", ["X"]], ["need ccl/", ["X"]], ["*.telescope/", ["X"]], ["many2add/", ["X"]], ["aug21/", ["X"]], ["binary/", ["X"]], ["_swap/", ["X"]], ["versions/", ["X"]], ["effect data/", ["X"]], ["*.off/", ["X"]], ["*many2add/", ["X"]], ["_has conflict*/", ["X"]], ["galaxy*/", ["X"]], ["additional_planets/", ["X"]], ["tmp/", ["X"]], ["*.dat; *.fragment, *.vertex", [" "]], [".mtl .obj", [" "]]]
FindExcluding = checked            // file search option for excluding all/checked file types
                                   //   in the list or just the current one
/*
 * listbox history (max. 20) of file Search text & its 'checked' status
 */
FindSearches = [["Timer", [" "]], ["_paddingText", [" "]], ["HUDs:", [" "]], ["player.ship.hud", [" "]], ["debugConfig.plist", [" "]], ["manifest.plist", [" "]], ["identlock", [" "]], ["identkeypress", [" "]], ["this.name", [" "]], ["manifext.plist", [" "]], ["readme.txt", [" "]], ["_forcedStationLaunch _generateAlienItemPrice", [" "]], ["frame_delta", [" "]], ["_generateAlienItemPrice", [" "]], ["_forcedStationLaunch", [" "]], ["end of closure", [" "]], ["IST_lobster_acolyte", [" "]], ["shaders", [" "]], ["acs_anaconda", [" "]], ["!!NOTE: Escorts required", [" "]]]
FindIgnoreCase = no                // file search toggle for case sensitivity
FindMatchAll = no                  // file search toggle for matching all (vs any) terms
FindQuitOnFirst = no               // file search toggle for halting search of a file once
                                   //   a match has been found (faster search)
FindSubDirs = yes                  // file search toggle for searching sub-folders
FindOxzFiles = yes
FindContextLines = 12              // # of surrounding lines to display with file search matches
FindTreatment = Token              // one of 'Token', 'Word', 'Substring', 'Regex' or 'File'
                                   //   for how search terms should be considered

[Aliases]
/*
 * an alias is a way to reduce keystrokes/errors.  They are added as properties
 * to console.script.  There are 4 pre-defined aliases in the Basic-debug.oxp script
 * "oolite-debug-console.js":
 *   P = player,  PS = player.ship,  S = system &  M = missionVariables
 * An alias can be a reference, like these, or a value, object, function or an IIFE!
 * NB: if entering one manually, use <name> := ...
 *     this make parsing much easier, as := is not valid in JavaScript
 */
__lotsInline :=   /*fn Lead*/ function lotsInline( /*fn Args*/ )   /*fn Head*/{
/* first line*/
    var ship = console.script._constrictorShip_;
    if (!ship) {
/* log(("_showCon, !ship => no Constrictor"));*/
        return;
    }
 /* 1st of 2 */
/* Reset the Counter if it reaches 100.*/
    if (missionVariables.random_station_names_timer > 99) {
        missionVariables.random_station_names_timer = 0;
    }
/* The easter egg mission will pay you*/
/* 2nd of 2*/
    if (console.script.hasOwnProperty("_constrictorFCB_")) {
/* if (console.script.hasOwnProperty("_constrictorFCB_")) {*/
        var fcb = console.script._constrictorFCB_;
        if (fcb && isValidFrameCallback(fcb)) {
            removeFrameCallback(fcb);
            console.script._constrictorFCB_ = null;
        }
    }
    ship.switchAI("oolite-nullAI.js");
    ship.isCloaked = false;
    log("_clkOff, Constrictor is NOT cloaked");

/* last line*/
/* last line2*/
}
/* post Args*/
__pad := N:function _paddingText(currentText, desiredLength) {
    var that = _paddingText;
    var floor = that.floor = that.floor || Math.floor;
    var round = that.round = that.round || Math.round;
    var strFontLen = that.strFontLen = that.strFontLen || defaultFont.measureString;
    var hairSpace = that.hairSpace = that.hairSpace || String.fromCharCode(8202);
        // 1/8 width space; while there are also 1/4 & 1/2 width unicode chars, MacOS only supports this one!
    var hairSpaceLength = that.hairSpaceLength = that.hairSpaceLength || strFontLen(hairSpace);
    var spaceLength = that.spaceLength = that.spaceLength || strFontLen(" ");
    var padding = that.padding = that.padding || [];
    if (desiredLength <= 0) {
        log("\n_paddingText, desiredLength: " + desiredLength + " <= 0, aborting");
        return "";
    }
    var num, padString = "";
    var currentLength = strFontLen(currentText);
    var lengthNeeded = desiredLength - currentLength;
    if (lengthNeeded <= 0) {
        log("\n_paddingText, lengthNeeded: " + lengthNeeded + " <= 0, aborting");
        return "";
    }
    num = floor(lengthNeeded / spaceLength);
    rpt = "\ndesiredLength: " + desiredLength + ", currentLength: " + currentLength.toFixed(2) + ", lengthNeeded: " + lengthNeeded.toFixed(2) + ", space num: " + num;
    if (num > 0) {
       // need at least 2 to use array length/join trick
        padding.length = num + 1;
        padString += padding.join(" ");
        lengthNeeded -= num * spaceLength;
        rpt += "  space padding: \"" + padding.join(" ") + "\", len: " + padding.join(" ").length;
        // } else if( num === 1 )
    // {
// rpt += '  adding a single space';
    // padString += ' ';
    // lengthNeeded -= spaceLength;
    }
    log(rpt);
    num = round(lengthNeeded / hairSpaceLength);
    rpt = "\ndesiredLength: " + desiredLength + ",                   " + ", lengthNeeded: " + lengthNeeded.toFixed(2) + ", space num: " + num;
    if (num > 0) {
       // need at least 2 to use array length/join trick
        padding.length = num + 1;
        padString += padding.join(hairSpace);
        rpt += "  hair padding: \"" + padding.join(hairSpace) + "\", len: " + padding.join(hairSpace).length;
        // } else if( num === 1 )
    // {
// rpt += '  adding a single hair';
    // padString += hairSpace;
    }
    log(rpt);
    log("returning \"" + padString + "\", len: " + padString.length);
    return padString;
}
__tmp := N:  function (delta) {
    var w = this; //worldscript
    var p = player.ship;
    var pp = false;
    if (p && p.isValid) {
        pp = p.position;
    }
    w.$FC++; //frame counter for calculating FPS
    w.$Delta += delta;
    if (w.$Delta > w.$Delta2 + 1 && pp) { // like an 1s timer, search for new ships
        w.$FPS = w.$FC; //save measured fps for the trail length reducer code below
        w.$FC = 0; //reset frame counter
        w.$Delta2 = w.$Delta; //save delta

        //No trails in red alert below 50 FPS if weapons are online
        if (player.alertCondition > 2 && p.weaponsOnline) {
            if (!w.$Red && w.$FPS < w.$GoodFPS) {
                                //first time after red alert started
                w.$RemoveAllTrails(w);
                w.$Red = true;
            } //restore trails in red alert over 100FPS only
            if (w.$Red && w.$FPS < 2 * w.$GoodFPS) {
                return;
            }
        }
        w.$Red = false;
        var ships = [];
        if (!p.docked) {
            ships = p.checkScanner(false);//faster than filteredEntities
        }
                //must use checkScanner with false to add the "green" escorts
                //and a good side effect boulders get steam tails
                //moreover true return the full list in Oolite 1.80 (fixed in 1.81)
        for (var i = 1; i < w.$S.length; i++) { //remove trails of far ships
            var o = w.$S[i]; //data of an old ship
            var x = - 2;
            if (o && o[0] && o[0].isValid) {
                x = ships.indexOf(o[0]);
                if (w.$ED) { //disable escort trails on deck, enable if launched
                    if (!o[0].script) { //for sure
                        o[0].setScript("oolite-default-ship-script.js");
                    }
                    var pad = w.$ED.$EscortDeckShip.indexOf(o[0]);
                    if (pad != - 1) { //change on ships used by escortdeck only
                        if (w.$ED.$EscortDeckShipPos[pad]) {
                            o[0].script.$TrailsDisabled = true;
                        } else {
                            o[0].script.$TrailsDisabled = false;
                        }
                    }
                }
            }
            //if invalid then docked, jumped or destroyed, leave to run remove below
            if (x == - 1) { //not in the scanner anymore?
                //must check distance due to many ships near exhibitions
                //can leave out important ones from the limited checkScanner list
                if (pp.distanceTo(o[0].position) > 2 * p.scannerRange) {
                    for (var k = 3; k <= w.$Length; k++) {
                        var v = o[k]; //remove visualEffects
                        if (v && v.isValid) {
                            v.remove();
                        }
                    }
                    w.$S[i] = false; //remove this ship from the tracked array
                }
            } else if (x >= 0) {
                ships[x] = false; //don't add into $S if already in

            }
        }
        if (p.docked) {
            if (w.$S[1]) {
                w.$Clear(w); //start a new array, free up memory
            }
        } else {
            for (var i = 0; i < ships.length; i++) { //add new ships into $S
                var ship = ships[i];
                if (ship &&
                    ship.isValid &&
                    ship.maxSpeed > 0 //do not add buoy, etc.
                    &&
                    (ship.exhausts && ship.exhausts[0] //need valid exhaust
                    ||
                    ship.scanClass == "CLASS_ROCK") &&
                    !ship.isMissile &&
                    ship.primaryRole != "wreckage" //exclude for explosions
                    &&
                    ship.primaryRole != "oolite-wreckage-chunk" &&
                    ship.primaryRole != "alloy" &&
                    ship.primaryRole != "cargopod" &&
                    ship.primaryRole != "griffspark" //explosion in griffs wreckages
                    &&
                    ship.dataKey != "telescopemarker" //exclude for Telescope
                    &&
                    ship.mass > 10000 //exclude TIE fighters and too small ships
                    && ship.scanClass != "CLASS_NO_DRAW") { //exclude for sure
                //do not add escorts landed on EscortDeck
                    var add = true;
                    if (w.$ED) {
                        var pad = w.$ED.$EscortDeckShip.indexOf(ship);
                        if (pad != - 1 && w.$ED.$EscortDeckShipPos[pad]) {
                            add = false;
                        }
                    }
                    if (add) {
                        var l = w.$S.length; //add after the last ship
                        w.$S[l] = [];
                        w.$S[l][0] = ship;
                        w.$T[l] = [];
                    }
                }
            }
        }
    }
    if (w.$Red) {
        return; //No trails in red alert below 50 FPS if weapons are online
    }

    //reduce the number of flashers if FPS is low
    var newkey = false;
    if (w.$FPS < w.$LowFPS) {
        if (w.$Key > 1) {
            w.$Key--;
            newkey = true;
//                      player.consoleMessage("FPS:"+w.$FPS+" key:"+w.$Key); //debug
        }
        w.$FPS = w.$LowFPS; //do not reduce again until the next measue
    } else if (w.$FPS > w.$GoodFPS) { //extend up to maxkey
        if (w.$Key < w.$MaxKey) {
            w.$Key++;
            newkey = true;
//                      player.consoleMessage("FPS:"+w.$FPS+" key:"+w.$Key); //debug
        }
        w.$FPS = w.$GoodFPS; //do not extend again until the next measue
    }
    var key = "trails" + w.$Key;
    if (newkey) {
        w.$Sec = w.$MaxSec - 2 * w.$MaxKey + 2 * w.$Key;
    }

    //reduce length over 1500 entity to prevent "Universe is full" error at 2047
    var a = system.allShips.length + system.allVisualEffects.length;
    var r = w.$Length;
    if (a > 1500 && w.$Length > 10) { //too much entity
        r = Math.ceil(w.$Length / 2); //reduced length
        w.$RemoveAllTrails(w); //restart trails
        w.$Length = r;
    }
    var zoom = w.$Zoom;

    //create new trail elements
    var dist = w.$Distance;
    var shift = w.$Shift;
    var ma = w.$MaxAngle;
    for (var i = 1; i < w.$S.length; i++) { //start from 0 and player ship will make trail also
        var t = w.$S[i];
        if (t) {
            var ship = t[0];
            if (ship &&
                ship.isValid &&
                !ship.isDerelict && !ship.script.$TrailsDisabled) {
                var sp = ship.position;
                var sc = 1;
                if (ship.scanClass == "CLASS_ROCK") {
                    key = "trails-rock";
                } else {
                    key = "trails" + w.$Key;//need if the previous ship was over 12km
                    if (pp) { //create less flashers over 12km
                        var pd = sp.distanceTo(pp) / 1000;
                        if (pd > 12) {
                            key = "trails0";
                            if (zoom) { //increase size in 12-20km for brightness
                                sc = 1.5 + Math.max(0, Math.min(2, pd / 5 - 2));
                            } //below the same formula is used again, keep these equal
                        }
                    }
                }
                var c = 0; //safety counter to surely exit from the next cycle soon
                //check distance of the last position where a trail is created
                //need to do in cycle if travelled more in the last frame than
                //the length of a visualEffect element in effectdata.plist (20m)
                //which is happen often with more than 1x TAF
                var k = t[2];
                var bp = sp;//.add(ship.heading.multiply(w.$Distance));//start earlier
                var ez = 1; //default for ships without engine like rocks
                var e = ship.exhausts; //use engine exhaust z distance from ship center
                if (e && e[0] && e[0].position && e[0].position.z) {
                    ez = 1 - Math.min(0, e[0].position.z); //ez must >=1 for Gnat
                }
                var kp = bp;
                if (t[k] && t[k].isValid) {
                    kp = t[k].position;
                    if (kp.x > 0.9 * shift) {//moved far away
                        kp = Vector3D(kp.x - shift, kp.y, kp.z);
//                                              if(p.target == ship) log(w.name, ship.name+" far i:"+i); //debug
                    }
                }
                var kv = t[k];
                while (c < 50 &&
                    (!k ||
                    !kv || !kv.isValid || bp.distanceTo(kp) > dist / 2 + ez)) {
                    c++;
                    if (!w.$S[i][2]) {
                        w.$S[i][2] = 3; //new trail
                    }
                    k = w.$S[i][2];
                    if (!k) {
                        k = 3;
                    }
                    var a = w.$S[i][k]; //actual (lastly created) visualEffect
                    var pos = bp;
                    var q = ship.orientation; //for the first element
                    if (a && a.isValid) { //from the second element
                        var ap = a.position;
                        if (ap.x > 0.9 * shift) { //moved far away
                            ap = Vector3D(ap.x - shift, ap.y, ap.z);
                        }
                        var u = bp.subtract(ap).direction();
                        pos = ap.add(u.multiply(dist));
                        if (a && a.isVisualEffect) {
                            //facing from the previous trail element
                            q = a.orientation;
                            var z = pos.subtract(ap).direction();
                            var ah = a.heading;
                            var angle = ah.angleTo(z);
                            //set the plane where we should rotate in
                            var cr = ah.cross(z).direction();
                            q = q.rotate(cr, - angle);
                        }
                    }
//                  w.$S[i][1] = pos; //save the new position - unused

                    k++; //index of the next item
                    if (k > w.$Length) {
                        k = 3; //restart over $Length
                    }
                    w.$S[i][2] = k; //save the new index

/*                                      //make the end of the trail darker but prevent blue end on gray dust
                    if( ship.scanClass != "CLASS_ROCK" ) {
                            var pk = k+1; //previous k points to the oldest visualEffect
                            if( pk > w.$Length ) pk = 3;
                            var pv = w.$S[i][pk]; //the oldest visualEffect
                            if( pv && pv.isVisualEffect ) {
                                var nv = system.addVisualEffect(
                                    "trails-end", pv.position );
                                if( nv ) {
                                    nv.orientation = pv.orientation;
                                                                nv.scaleX = nv.scaleY = 0.5; //shrink
                                    pv.remove();
                                    w.$S[i][pk] = nv; //save the new item
                                                        }
                        }
                    }
*/
                    //move or replace old visual item
                    var ov = w.$S[i][k];
                    if (ov && ov.isVisualEffect && ov.dataKey == key) {
                        ov.position = pos;
                        ov.orientation = q;
                    } else {
                        if (ov && ov.isVisualEffect) {
                            ov.remove();
                        }
                        var v = system.addVisualEffect(key, pos);
                        if (v) {
                            v.orientation = q;
                            w.$S[i][k] = v; //save the new element
                        }
                    }
                    w.$T[i][k] = w.$Delta; //Timestamp of creation
                    kv = w.$S[i][k];
                    if (kv && kv.isValid) {
                        kp = kv.position;
                        if (kp.x > 0.9 * shift) { //moved far away
                            kp = Vector3D(kp.x - shift, kp.y, kp.z);
                        }
                    } else {
                        kp = bp;
                    }
                }
//              if(c > 40) log(w.name, ship.name+" new i:"+i+" c:"+c); //debug
                //increase flasher size with the distance
                if (sc > 1) {
                    for (var j = 3; j <= w.$Length; j++) {
                        var v = w.$S[i][j];
                        if (v && v.isValid) {
                            v.scaleX = v.scaleY = sc;
                        }               //but not scaleZ!
                    }
                }
            } else { //ship docked, jumped or destroyed
                var k = t[2]; //actual item index - old code without timestamp
                if (k) {
                    k++;// += 0.5; //slower count for slower remove
                    if (k > w.$Length) {
                        k = 3; //restart over $Length
                    }
                    w.$S[i][2] = k; //save the new index
                    if (k == Math.floor(k)) {
                        if (w.$S[i][k] == - 1) { //all visualEffect removed
                            //so remove this ship from the tracked array
                            for (var k = 3; k <= w.$Length; k++) {
                                var v = t[k]; //remove again for sure
                                if (v && v.isValid) {
                                    v.remove();
                                }
                            }
                            w.$S[i] = false;
                        } else {
                            var ov = t[k]; //remove old visual item
                            if (ov && ov.isVisualEffect) {
                                ov.remove();
                            }
                            w.$S[i][k] = - 1; //flag for remove ship
                        }
                    }
                }
            }
            if (pp &&
                ship && ship.isValid && ship.scanClass != "CLASS_ROCK") {
                var max = 1;
                var sd = ship.position.distanceTo(pp);
                if (!zoom) {
                    if (ship.mass < 20000) {
                        max = 0.2;
                    } else if (ship.mass < 30000) {
                        max = 0.4;
                    } else if (ship.mass < 130000) {
                        max = 0.8;
                    }
                } else {
                    if (sd > 12000) { //zoom in 12-20km, same formula as above
                        max = 1.5 + Math.max(0, Math.min(2, sd / 5000 - 2));
                    } else if (ship.mass < 20000) {
                        max = 0.4;
                    } else if (ship.mass < 30000) {
                        max = 0.8;
                    }
                }
//                              var c = 0;
                for (var j = 3; j <= w.$Length; j++) {
                    var v = w.$S[i][j];
                    if (v && v.isValid && w.$T[i][j]) {
//                                              c++;
                        if (w.$Delta > w.$T[i][j] + w.$Sec) { //timeout
                            v.remove();
                            w.$S[i][j] = null;
                            w.$T[i][j] = null;
                        } else {
                            var vp = v.position;
                            var ph = p.heading;
                            switch (p.viewDirection) {
                              case "VIEW_AFT":
                                ph = ph.multiply(- 1);
                                break;
                              case "VIEW_PORT":
                                ph = p.orientation.vectorRight().multiply(- 1);
                                break;
                              case "VIEW_STARBOARD":
                                ph = p.orientation.vectorRight();
                                break;
                              default:;
                            }

/*                                                      //reduce flashers if far or near parallel - cause jams
                                                        var key2 = key;
                                                        if( w.$Key == 1 ) {
                                                                var an = vp.subtract(pp).angleTo(v.heading);
                                                                if( vp.distanceTo( pp )>12000 || an<0.3 ) {
                                                                        key2 = "trails0";
                                                                //improve if not enough paralell
                                                                } else key2 = "trails1";
                                                                if(p.target==ship) log(w.name, //debug
                                                                    an+" i:"+i+" j:"+j+" x:"+vp.x+" "+key2);
                                                        }*/
                            if (w.$Key < 2 && v.dataKey != key) {
                                                                //immediately reduce quality in lowest mode
                                z = system.addVisualEffect(key, v.position);
                                if (z) {
                                    z.orientation = v.orientation;
                                    v.remove();
                                    w.$S[i][j] = z;
                                    v = z;
                                }
                            }

                                                        //time-based trail dissipation
                            var s = 4;
                            if (!zoom || sd < 12000) {
                                s = 2.01 - (w.$Delta - w.$T[i][j]) / w.$Sec * 2;
                            }
                                                        //s must be always greater than 0 for scale!
                            v.scaleX = v.scaleY = Math.min(max, s);//shrink

                                                        //performance boost:
                                                        //move far away if not in sight or over 15km
                            if (vp.x < 0.9 * shift) {
                                var ang = ph.angleTo(vp.subtract(pp));
                                if (ang >= ma || !zoom && sd > 15000) {
                                    v.position = Vector3D(vp.x + shift, vp.y, vp.z);
                                }
                            } else { //move back if in sight again
                                vp = Vector3D(vp.x - shift, vp.y, vp.z);
                                if (ph.angleTo(vp.subtract(pp)) < ma &&
                                    (zoom || sd <= 15000)) {
                                    v.position = vp;
                                }
                            }
                        }
                    }
                }
                                //if(c > 45) log(w.name, ship.name+" end i:"+i+" c:"+c); //debug
            }
        }
    }
}
_clk := NM: /*tooltip:fn Lead placed as first cmt*/ function ( /*fn Args*/ )   /*fn Head*/{
// first line
    var ship = console.script._constrictorShip_;
    if (!ship) {
// log(("_showCon, !ship => no Constrictor"));
        return;
    }
 /* 1st of 2 */
// Reset the Counter if it reaches 100.
    if (missionVariables.random_station_names_timer > 99) {
        missionVariables.random_station_names_timer = 0;
    }
// The easter egg mission will pay you
// 2nd of 2
    if (console.script.hasOwnProperty("_constrictorFCB_")) {
// if (console.script.hasOwnProperty("_constrictorFCB_")) {
        var fcb = console.script._constrictorFCB_;
        if (fcb && isValidFrameCallback(fcb)) {
            removeFrameCallback(fcb);
            console.script._constrictorFCB_ = null;
        }
    }
    ship.switchAI("oolite-nullAI.js");
    ship.isCloaked = false;
    log("_clkOff, Constrictor is NOT cloaked");

// last line
// last line2
}
// post Args
_clkOff := N:    // ToolTip: fn Lead
(function (/*fn Args*/)   /*fn Head*/{ // first line
    var ship = console.script._constrictorShip_;
    if (!ship) {
        log("_showCon, !ship => no Constrictor");
        // log(("_showCon, !ship => no Constrictor"));
        return;
    } /* 1st of 2 */
    // 2nd of 2
    if (console.script.hasOwnProperty("_constrictorFCB_")) {
    // if (console.script.hasOwnProperty("_constrictorFCB_")) {
        var fcb = console.script._constrictorFCB_;
        if (fcb && isValidFrameCallback(fcb)) {
            removeFrameCallback(fcb);
            console.script._constrictorFCB_ = null;
        }
    }
    ship.switchAI("oolite-nullAI.js");
    ship.isCloaked = false;
    log("_clkOff, Constrictor is NOT cloaked"); // last line
}/* fn Tail */)/*pre Args*/( // iife Args
)// post Args
_clkOn := N:(function () {

    function keepItCloaked() {
        var ship = console.script._constrictorShip_;
        if (!ship || !ship.isValid) {
            let fcb = console.script._constrictorFCB_;
            if (fcb && isValidFrameCallback(fcb)) {
                removeFrameCallback(fcb);
                console.script._constrictorFCB_ = null;
            }
        } else if (!ship.isCloaked) {
            ship.isCloaked = true;
        }
    }

    var ship = console.script._constrictorShip_;
    if (!ship) {
        log("_showCon, !ship => no Constrictor");
        return;
    }
    if (console.script.hasOwnProperty("_constrictorFCB_")) {
        let fcb = console.script._constrictorFCB_;
        if (fcb && isValidFrameCallback(fcb)) {
            removeFrameCallback(fcb);
        }
    }
    if (ship.energy < 200) {
        ship.energy = 200;
    }
    console.script._constrictorFCB_ = addFrameCallback(keepItCloaked.bind(console.script));
    log("_clkOn, Constrictor is cloaked");
})() //tooltip:after fn defn
_JamOff := NM:(function () {
    var ship = console.script._constrictorShip_;
    if (!ship) {
        log("_showJam, !ship => no Constrictor");
        return;
    }
    if (console.script.hasOwnProperty("_constrictorFCB_")) {
        let fcb = console.script._constrictorFCB_;
        if (fcb && isValidFrameCallback(fcb)) {
            removeFrameCallback(fcb);
            console.script._constrictorFCB_ = null;
        }
    }
    ship.switchAI("oolite-nullAI.js");
    ship.setEquipmentStatus("EQ_MILITARY_JAMMER", "EQUIPMENT_DAMAGED");
    log("_JamOff, military jammer disabled");
})()
_JamOn := NM:(function () {

    function keepItJammed() {
        var ship = console.script._constrictorShip_;
        if (!ship || !ship.isValid) {
            let fcb = console.script._constrictorFCB_;
            if (fcb && isValidFrameCallback(fcb)) {
                removeFrameCallback(fcb);
                console.script._constrictorFCB_ = null;
            }
        } else if (!ship.isJamming) {
            ship.isJamming = true;
        }
    }

    var ship = console.script._constrictorShip_;
    if (!ship) {
        log("_showCon, !ship => no Constrictor");
        return;
    }
    if (!ship.isJamming) {
        ship.setEquipmentStatus("EQ_MILITARY_JAMMER", "EQUIPMENT_OK");
        if (console.script.hasOwnProperty("_constrictorFCB_")) {
            let fcb = console.script._constrictorFCB_;
            if (fcb && isValidFrameCallback(fcb)) {
                removeFrameCallback(fcb);
            }
        }
        console.script._constrictorFCB_ = addFrameCallback(keepItJammed.bind(console.script));
    }
    log("_JamOn, Constrictor is " + (ship.isJamming ? "" : "NOT") + " jamming");
})()
_rel2ps := N:function (name, posOrEnt, distanceMaybe) {
    var cd = worldScripts.telescope_debug || worldScripts.cagsdebug;
    var ps = player && player.ship;
    var ps_position = ps.position;
    var posn = posOrEnt.constructor === Vector3D ? posOrEnt : Array.isArray(posOrEnt) ? new Vector3D(posOrEnt) : posOrEnt.position || null;
    if (!posn) {
        return "missing position for " + name;
    }
    var dist = distanceMaybe || posn.distanceTo(ps_position);
    var padding = "________________";
    var pname = padding.slice(name.length - 16) + name;
    if (name === "lightball") {
        pname = "__" + pname;
    }    // test cmt
    var vector = posn.subtract(ps_position);
    var fwd = (ps.vectorForward.angleTo(vector) * 180 / 3.1415927).toFixed(), right = (ps.vectorRight.angleTo(vector) * 180 / 3.1415927).toFixed(), up = (ps.vectorUp.angleTo(vector) * 180 / 3.1415927).toFixed();
    var fwdRpt = fwd < 90 ? "fore " + fwd + "\xB0, " : fwd > 90 ? "aft " + (fwd - 90) + "\xB0, " : "abeam, ";
    var rightRpt = right < 90 ? "\t starboard " + right + "\xB0, " : right > 90 ? "\t\tport " + (right - 90) + "\xB0, " : "no yaw, ";
    var upRpt = up < 90 ? "\tabove " + up + "\xB0 " : up > 90 ? "\tbelow " + (up - 90) + "\xB0 " : "no pitch, ";
    log(pname + " is " + fwdRpt + rightRpt + upRpt + "at " + cd._number_str(dist) + " m");
}
addCon := N:(function (pos) {
    var constrictor = system.addShips("constrictor", 1, pos, 0);
    var ship = constrictor[0];
    ship.bounty = 250;    // Attach script here and not in shipdata, so that like_ship copies of the constrictor have no mission script,
    // only the version used for the mission will have the script now.
    // constrictor[0].setScript("oolite-constrictor.js");
    constrictor[0].setScript("oolite-nullAI.js");
    if (ship.equipmentStatus("EQ_CLOAKING_DEVICE") !== "EQUIPMENT_OK") {
        ship.awardEquipment("EQ_CLOAKING_DEVICE");
    }

    function keepItCloaked() {
        var ship = console.script._constrictorShip_;
        if (!ship || !ship.isValid) {
            let fcb = console.script._constrictorFCB_;
            if (fcb && isValidFrameCallback(fcb)) {
                removeFrameCallback(fcb);
                console.script._constrictorFCB_ = null;
            }
        } else if (!ship.isCloaked) {
            ship.isCloaked = true;
        }
    }

    console.script._constrictorShip_ = ship;
    if (console.script.hasOwnProperty("_constrictorFCB_")) {
        let fcb = console.script._constrictorFCB_;
        if (fcb && isValidFrameCallback(fcb)) {
            removeFrameCallback(fcb);
        }
    }
    console.script._constrictorFCB_ = addFrameCallback(keepItCloaked.bind(console.script));
    log("addCon, constrictor ship added");
})(player.ship.position.add(player.ship.heading.multiply(5000)))
addJam := NM:(function (pos) {
    var constrictor = system.addShips("pirate", 1, pos, 0);
    var ship = constrictor[0];
    ship.bounty = 250;    // Attach script here and not in shipdata, so that like_ship copies of the constrictor have no mission script,
    // only the version used for the mission will have the script now.
    // constrictor[0].setScript("oolite-constrictor.js");
    constrictor[0].setScript("oolite-nullAI.js");
    if (ship.equipmentStatus("EQ_MILITARY_JAMMER") !== "EQUIPMENT_OK") {
        ship.awardEquipment("EQ_MILITARY_JAMMER");
    }

    function keepItJammed() {
        var ship = console.script._constrictorShip_;
        if (!ship || !ship.isValid) {
            let fcb = console.script._constrictorFCB_;
            if (fcb && isValidFrameCallback(fcb)) {
                removeFrameCallback(fcb);
                console.script._constrictorFCB_ = null;
            }
        } else if (!ship.isJamming) {
            ship.isJamming = true;
        }
    }

    console.script._constrictorShip_ = ship;
    if (console.script.hasOwnProperty("_constrictorFCB_")) {
        let fcb = console.script._constrictorFCB_;
        if (fcb && isValidFrameCallback(fcb)) {
            removeFrameCallback(fcb);
        }
    }
    console.script._constrictorFCB_ = addFrameCallback(keepItJammed.bind(console.script));
    log("addJam, pirate ship added");
})(player.ship.position.add(player.ship.heading.multiply(5000)))
cd := N:worldScripts.cagsdebug
cfg := NM:(function () {
    ws._report_config("config");
})()
cfge := NM:(function () {
    ws._report_config("experimental");
})()
cp := P:player // no poll but should by default
crbb := N:(function (ent) {
    var label = "ent:";
    if (!ent || !ent.boundingBox) {
        ent = player.ship && player.ship.target;
        if (!ent) {
            return;
        }
        let ws = worldScripts.telescope;
        let curr_S = ws && ws.$curr_Sighting;
        if (curr_S && ent === curr_S.marker) {
            ent = curr_S.ent || null;
        }
        if (!ent || !ent.boundingBox) {
            return;
        }
        label = "target:";
    }
    var bb = ent.boundingBox, cr = ent.collisionRadius;
    var cRad = Math.sqrt(bb[0] * bb[0] + bb[1] * bb[1] + bb[2] * bb[2]) / 2;
    var ratio = cr / cRad;
    log(label + " " + ent.dataKey + ", collisionRadius: " + cr.toFixed(4) + ", from boundingBox: " + cRad.toFixed(4) + ", ratio cc/fromBb: " + ratio.toFixed(4));
})()
cs := N:worldScripts.telescope.$curr_Sighting
csh := N:worldScripts.customShipyard

csMap := NM:(function () {
    var cd = worldScripts.cagsdebug;
    var csm = worldScripts.telescope.$curr_Sighting.map;
    if (cd && csm) {
        cd._display_map(csm);
    }
})()
cst := P:worldScripts.telescope.$curr_Sighting.ent
descrV := NM:    // eg. ps.heading.dot( ps.heading ) is not 1 but upto plus 4.30704e-8 and minus 2.24969e-7
    // standard for equality: a - b < PRECISION => essentially equal; using 6 as .dot fluctuates
    // .dot -1..0..1 spans PI radians; abs spans PI/2
(function (vect) {
    const PRECISION = 0.000001;

    function equal_value(a, b) {
        return Math.abs(a - b) < PRECISION;
    }

    var rad2deg = 180 / Math.PI;
    var v = vect.direction();
    var dot2deg = rad2deg * Math.PI / 2;
    var msg = " -> vector points ", decimals = 3;
    var dotForward = v.dot(ps.vectorForward), diffForward = Math.abs(dotForward) * dot2deg;
    var dotRight = v.dot(ps.vectorRight), diffRight = Math.abs(dotRight) * dot2deg;
    var dotUp = v.dot(ps.vectorUp), diffUp = Math.abs(dotUp) * dot2deg;
    var fwdMsg = false;
    if (equal_value(dotForward, 1)) {
        msg += "directly on heading";
        fwdMsg = true;
    } else if (!equal_value(dotForward, 0)) {
        msg += diffForward.toFixed(decimals) + "\xB0 ";
        msg += dotForward > 0 ? "fore " : "aft ";
        msg += dotUp > 0 ? "of zenith" : "of nadir";
        fwdMsg = true;
    }
    if (!equal_value(dotRight, 0)) {
        if (fwdMsg) {
            msg += ", ";
        }
        msg += diffRight.toFixed(decimals) + "\xB0 ";
        msg += dotRight > 0 ? "starboard" : "port";
    }
    if (!equal_value(dotUp, 0)) {
        if (fwdMsg) {
            msg += ", ";
        }
        msg += diffUp.toFixed(decimals) + "\xB0 ";
        msg += dotUp > 0 ? "up" : "down";
    }
    log(msg);
})(ws.$tmpV)
dist := NM:function (ent) {
    var ps = player.ship, ws = worldScripts.telescope;
    if (!ent) {        // if none supplied, default to player's target
        ent = ps.target;
    }
    if (ws && ent.dataKey === "telescopemarker") {
        ent = ws.$TelescopeList[ws.$TelescopeListi - 1];
    }
    // print distance & relativeDirection
    var cnv = 180 / Math.PI;
    var vect = ent.position.subtract(ps);
    var dist = vect.magnitude() - ent.collisionRadius, uvect = vect.direction(), fdot    /* unit vector to target */
    = uvect.dot(ps.vectorForward), rdot = uvect.dot(ps.vectorRight), udot = uvect.dot(ps.vectorUp);
    msg    // cosine of angle wrt uvect
    = "dist: " + dist.toFixed() + ", " + (fdot >= 0 ? "ahead" : "behind");
    msg += ": " + (Math.acos(fdot) * cnv).toFixed(2) + " degrees off center" + ", ";
    msg += (rdot >= 0 ? "right" : "left") + ": " + (90 - Math.acos(rdot) * cnv).toFixed(2);
    msg += " degrees" + ", " + (udot >= 0 ? "up" : "down") + ": " + (90 - Math.acos(udot) * cnv).toFixed(2) + " degrees";
    log(msg);
}
dmap := NM:function () {
    worldScripts.cagsdebug._dump_map();
}
ed := N:es._occulted.targetData
ef := P:worldScripts.eclipseSpotter.$debugEffects
eff := P:function () {
    if (Object.keys(es.$debugEffects).length === 0) {
        log("debugEffects is empty");
        return;
    }
    var lns = [];
    for (let e in es.$debugEffects) {
        if (!isNaN(parseInt(e.substr(- 1)))) {
            continue;
        }
        let eff = es.$debugEffects[e];
        let dk = eff.dataKey.replace("telescope-", "").replace("_dotmarker", "");
        lns.push(dk + "\t" + eff.scaleX.toFixed(2) + "\t" + e);
    }
    lns.sort();
    for (let x = 0, len = lns.length; x < len; x++) {
        log(lns[x]);
    }
}
es := N:worldScripts.eclipseSpotter
fCon := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: continuous, no filter
    ws.$MFDFiltering = false;
    ws.$SeparateMFDs = true;
    //     ws.$MFDPrimaryStatic = MFD_NEUTRAL;
    //    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    //    ws.$MFDAuxStatic = MFD_NEUTRAL | MFD_NAVIGATION;
    //    ws.$MFDAuxDynamic = MFD_FARAWAY;
    ws._reload_config();
    log("filter: continuous");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fFar := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: navigation: near, far
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_STATION | MFD_NAVIGATION | MFD_CELESTIAL;
    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    ws.$MFDAuxStatic = MFD_STATION | MFD_NAVIGATION | MFD_CELESTIAL;
    ws.$MFDAuxDynamic = MFD_FARAWAY;
    ws._reload_config();
    log("filter: far (nav. only)");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fHunt := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: bounty hunter filter
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_PIRATES | MFD_SALVAGE;
    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    ws.$MFDAuxStatic = MFD_TRADERS | MFD_NEUTRAL | MFD_NAVIGATION;
    ws.$MFDAuxDynamic = MFD_RANGED;
    ws._reload_config();
    log("filter: bounty hunter");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fMil := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: military filter
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_MILITARY;
    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    ws.$MFDAuxStatic = MFD_MILITARY;
    ws.$MFDAuxDynamic = MFD_FARAWAY;
    ws._reload_config();
    log("filter: military");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fMine := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: mining filter
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_ORIENT | MFD_POLICE | MFD_PIRATES | MFD_MILITARY;
    ws.$MFDPrimaryDynamic = MFD_RANGED;
    ws.$MFDAuxStatic = MFD_INANIMATE;
    ws.$MFDAuxDynamic = MFD_RANGED;
    ws._reload_config();
    log("filter: miner");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fNavHostile := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: hostiles/nav filter
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_HOSTILE | MFD_ACTIVE;
    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    ws.$MFDAuxStatic = MFD_STATION | MFD_NAVIGATION | MFD_CELESTIAL;
    ws.$MFDAuxDynamic = MFD_RANGED;
    ws._reload_config();
    log("filter: nav. w/ hostiles");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fOff := NM:(function () {
    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;        // getter invokes iife
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: no filter/2nd MFD off
    ws.$MFDFiltering = false;
    ws.$SeparateMFDs = false;
    ws._reload_config();
    log("filter: off");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fPirate := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET = 127;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: pirate filter
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_TRADERS | MFD_SALVAGE;
    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    ws.$MFDAuxStatic = MFD_TRADERS | MFD_POLICE | MFD_ORIENT;
    ws.$MFDAuxDynamic = MFD_RANGED;
    ws._reload_config();
    log("filter: pirate");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fPol := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: police filter
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_POLICE;
    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    ws.$MFDAuxStatic = MFD_POLICE;
    ws.$MFDAuxDynamic = MFD_FARAWAY | MFD_ORIENT;
    ws._reload_config();
    log("filter: police");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fTrade := NM:(function () {
    const MFD_SALVAGE = 1,          // cargo, escape pods, derelicts
    MFD_MINING = 2,    // asteroids, boulders, splinters & metal fragments
    MFD_WEAPONS = 4,    // mines & missiles
    MFD_INANIMATE = 7,    // those of 1st 3 flags excluded from dynamic filtering
    MFD_TRADERS = 8,    // ships .isTrader & escorts
    MFD_POLICE = 16,    // scanClass === "CLASS_POLICE"
    MFD_PIRATES = 32,    // .isPirate & .isPirateVictim
    MFD_MILITARY = 64,    // scanClass === "CLASS_MILITARY"
    MFD_ALIENS = 128,    // scanClass === "CLASS_THARGOID"
    MFD_NEUTRAL = 256,    // scanClass === "CLASS_NEUTRAL" and not in any above category (e.g., miners, hunters, etc.)
    MFD_ALLSHIPS = 504,    // all of the previous 6
    MFD_STATION = 512,    // .isStation
    MFD_NAVIGATION = 1024,    // some stations & beacons (may include a ship if emitting a beacon)
    MFD_CELESTIAL = 2048,    // sun, planets, moons
    MFD_ORIENT = 3584;    // all of the previous 3    // ws.$MFD_STATIC_ALLSET = 4095;

    const MFD_FRIENDLY = 1,    // bounty === 0 && !markedForFines
    MFD_UNSOCIABLE = 2,    // bounty || markedForFines
    MFD_ACTIVE = 4,    // has .target || defenseTargets.length > 0
    MFD_HOSTILE = 8,    // in_ents_Targets || targetting_ps
    MFD_ATTITUDE = 15,    // those of 1st 4 flags used to choose targets
    MFD_NEARBY = 16,    // distance < scannerRange
    MFD_PROTECTED = 32,    // .withinStationAegis
    MFD_FARAWAY = 64,    // distance > scannerRange
    MFD_RANGED = 112;    // those of prev. 3 flags used to limit those chosen    // ws.$MFD_DYNAMIC_ALLSET;

    if (!ws.$DebugMessages) {
        ws.$DebugMessages = true;
        let tmp = console.script.treset;
    }
    ps.setMultiFunctionText(ws.$PrimaryMFD_name, "", false);
    ps.setMultiFunctionText(ws.$AuxilaryMFD_name, "", false);
    // tooltip: trader filter
    ws.$MFDFiltering = true;
    ws.$SeparateMFDs = true;
    ws.$MFDPrimaryStatic = MFD_SALVAGE | MFD_MINING | MFD_TRADERS | MFD_PIRATES;
    ws.$MFDPrimaryDynamic = MFD_NEARBY;
    ws.$MFDAuxStatic = MFD_POLICE | MFD_PIRATES | MFD_ORIENT;
    ws.$MFDAuxDynamic = MFD_FARAWAY;
    ws._reload_config();
    log("filter: traders");
    ws._report_config("experimental");
    ws.update_MFDs(null, true);
})()
fz := NM:(function freeze() {

    function drain(ents) {
        for (let x = 0, len = ents.length; x < len; x++) {
            let ent = ents[x];
            if (!ent || !ent.isValid) {
                continue;
            }
            if (!ent.isFrangible) {
                continue;
            }
            ent.velocity = NULL_VECTOR;
            ent.roll = ent.maxRoll = 0;
            ent.pitch = ent.maxPitch = 0;
            ent.yuaw = ent.maxYaw = 0;
        }
    }

    var ps = player && player.ship;
    var ents, NULL_VECTOR = Vector3D([0, 0, 0]);
    ents = system.entitiesWithScanClass("CLASS_ROCK", ps, ps.scannerRange);
    drain(ents);
    ents = system.entitiesWithScanClass("CLASS_CARGO", ps, ps.scannerRange);
    drain(ents);
})()
hs := PM:(function hudShift() {
    ws.$VTarget_HUD_shift = [- 18.75, 3.75, 0];
    //    ws.$VTarget_HUD_shift = [0, 0, 0];
    ws._set_vShip_posn(ps.viewPositionForward, ws.$VTarget_HUD_shift);
    ws._reload_config();
})()
ht := NM:(function () {
    player.ship.hudHidden = !player.ship.hudHidden;
    log("hudHidden is " + player.ship.hudHidden);
})()
    // 2 consecutive invocations will fail if done too fast
p0 := N:system.planets[0]
p1 := N:system.planets[1]
p2 := N:system.planets[2]
p3 := N:system.planets[3]
p4 := N:system.planets[4]
p5 := N:system.planets[5]
pd := P:worldScripts.eclipseSpotter._boundingBoxRay.playerData
ps := P:player.ship
 // test cmt on plain alias
psp := P:player.ship.position
s0 := N:system.stations[0]
s1 := N:system.stations[1]
s2 := N:system.stations[2]
s3 := N:system.stations[3]
s4 := N:system.stations[4]
s5 := N:system.stations[5]
s6 := N:system.stations[6]
s7 := N:system.stations[7]
s8 := N:system.stations[8]
s9 := N:system.stations[9]
sbb := N:
// sbb head
es._occulted.stnBBox
// sbb tail
scrnShot := N:/* lead 1 */
// lead 2
function (showHUD) { // default screen shot has HUD hidden

    function _hideIt() {
        // hide HUD, stop timers if last in sequence
        var cs = console.script;
        if (cs._debugShootWithHUD_) {
            player.ship.hudHidden = cs._debugHUDstate_;
            cs._debugHUDoffTimer_.stop();
            cs._debugSnapShotTimer_.stop();
            cs._debugHUDonTimer_.stop();
        } else {
            player.ship.hudHidden = true;
        }
    }


    function _showIt() {
        // show HUD, stop timers if last in sequence
        var cs = console.script;
        if (cs._debugShootWithoutHUD_) {
            player.ship.hudHidden = cs._debugHUDstate_;
            cs._debugHUDoffTimer_.stop();
            cs._debugSnapShotTimer_.stop();
            cs._debugHUDonTimer_.stop();
        } else {
            player.ship.hudHidden = false;
        }
    }

    var cs = console.script, step = 0.2;
    if (showHUD === undefined || showHUD === null) {
        showHUD = false;
    }
    cs._debugShootWithHUD_ = showHUD;
    cs._debugShootWithoutHUD_ = !showHUD;
    cs._debugHUDstate_ = player.ship.hudHidden;
    if (!cs.hasOwnProperty("_debugHUDoffTimer_")) {
        cs._debugHUDoffTimer_ = new Timer(cs, _hideIt, cs._debugShootWithoutHUD_ ? step : step * 3, 1);
        cs._debugSnapShotTimer_ = new Timer(cs, function () {takeSnapShot();}, step * 2, 1);
        cs._debugHUDonTimer_ = new Timer(cs, _showIt, cs._debugShootWithHUD_ ? step : step * 3, 1);
        return;
    }
    var HUDoffTimer = cs._debugHUDoffTimer_, SnapShotTimer = cs._debugSnapShotTimer_, HUDonTimer = cs._debugHUDonTimer_;
    if (HUDoffTimer.isRunning) {
        HUDoffTimer.stop();
    }
    if (SnapShotTimer.isRunning) {
        SnapShotTimer.stop();
    }
    if (HUDonTimer.isRunning) {
        HUDonTimer.stop();
    }
    var currSec = clock.absoluteSeconds;
    HUDoffTimer.nextTime = currSec + (cs._debugShootWithoutHUD_ ? step : step * 3);
    SnapShotTimer.nextTime = currSec + step * 2;
    HUDonTimer.nextTime = currSec + (cs._debugShootWithHUD_ ? step : step * 3);
    HUDoffTimer.start();
    SnapShotTimer.start();
    HUDonTimer.start();
}
// tail 1
/* tail 2 */
scrS := NM:(function () {
    console.script.scrnShot();
})()
scrShud := NM:(function () {
    console.script.scrnShot(true);
})()
slock := N:(function () {
    var sl = worldScripts.sniperlock;
    if (sl === null) {
        return;
    }
    if (sl.deactivate == "TRUE") {
        sl.deactivate = "FALSE";
    } else if (sl.deactivate == "FALSE") {
        sl.deactivate = "TRUE";
    }
    log("sniperlock.deactivate = " + sl.deactivate);
})()
sreset := NM:(function () { // station options IIFE for reloading new closure code
    // console.clearConsole(); comment for debug
    var ws = worldScripts.telescope;
    var so = worldScripts.station_options;
    delete so._setInterfaces;    // so closure will be re-invoked

    // for testing
    //    so.$O_initStationOptions(ws, "telescope_", ws._stnOptionsAllowed, true, ws._reloadFromStn); // , true , "summary" , "autosave"
    ws._startStationOptions();

    // for testing multiple oxps
    // var fs = worldScripts.fps_monitor;
    // so.$O_initStationOptions( fs, "fps_monitor_", null, false, fs._reload_options );
    so._setInterfaces();    // player.ship.hudHidden = false;
    so.$optionsStarted = false;
})()
ss := N:system.stations
st := N:worldScripts.station_options
Targ20 := N:(function (name) {
    ws.$MaxTargets = 20;
    ws._reload_config();
    ws._report_config("config");
})()
tbrk := NM:(function () { // test telescope damage handling
    var ps = player && player.ship;
    var ws = worldScripts.telescope;
    /* break everything */
    ps.setEquipmentStatus("EQ_TELESCOPE", "EQUIPMENT_DAMAGED");
    // setting 0 awaits cheap repair
    ws.$FixedTel = 0;
})() /* good for missionVariables */
td := P:es._occulted.targetData
tfix := NM:(function () {
    var ps = player && player.ship;
    var ws = worldScripts.telescope;
    ps.setEquipmentStatus("EQ_TELESCOPE", "EQUIPMENT_OK");
    ws.$FixedTel = 0;
    ps.setEquipmentStatus("EQ_GRAVSCANNER", "EQUIPMENT_OK");
    ws.$FixedGS = 0;
    ps.setEquipmentStatus("EQ_SMALLDISH", "EQUIPMENT_OK");
    ws.$FixedSD = 0;
})()
treset := NM:(function () { // telescope IIFE for reloading new _Sightings_closure
    var ws = worldScripts.telescope;
    // console.clearConsole(); comment for debug
    ws._StopTimer();
    ws._shutdown_Sightings();
    ws._init_Sightings_closure();
    // for debugging  Sighting
    if (ws.$DebugMessages) {
        ws._debug_Sightings_closure();
    }
    //ws.time_create = sc.time_create;                  ws.time_update = sc.time_update;                //cagiife
    //ws.time_refresh = sc.time_refresh;                ws.profile_create = sc.profile_create;        //cagiife
    //ws.profile_update = sc.profile_update;            ws.profile_refresh = sc.profile_refresh;        //cagiife
    //ws.set_profiling = sc.set_profiling;              ws.clear_profiling = sc.clear_profiling;            //cagiife
    ws._initOxpVars();
    ws._set_vShip_posn(ps.viewPositionForward, ws.$VTarget_HUD_shift);    // NB: these are basically shipLaunchedFromStation, so comment out if testing involves launch
    ws._init_player_vars(true);
    ws._restart_after_shutdown();
    ws._create_Sightings();
    ws._StartTimer(1);
})()    // */
tsm := NM:worldScripts.telescope.$SightingsMap
vr := P:worldScripts.telescope.$vring
vs := P:worldScripts.telescope.$vship
wg := N:worldScripts.RandomStationNames
ws := N:worldScripts.telescope
wsc := P:worldScripts.telescope.$Sighting_closure
wt := N:worldScripts.towbar
